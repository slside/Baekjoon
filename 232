import java.util.Scanner;

public class Main {

	static String N;
	static int[] arr;
	static int ans;
	public static void main(String[] args) {
		// 행운의 문자열 1342  실버 1
		// 인접해 있는 문자가 모두 같지 않은 문자열 --> 행운의 문자열 
		// ex) abababa , ab , acde 
		// 이 경우는 x -> aab  - aa가 붙어있음
		
		// 먼저 문자열을 입력받아
		// arr 배열에 현재 문자의 개수만큼
		// ++ 해주고 
		// 재귀 돌려서 직접 다 세기
		Scanner sc = new Scanner(System.in);	
		N = sc.next(); // N을 입력받고 알파벳은 총 26개로
		// arr 배열은 26개를 선언해준다
		// (알파벳 소문자이므로 각 0~26값을 가지도록 하려고 int배열 선언)
		arr = new int[26]; // 직접 세보니 26개		
		for(int i =0;i<N.length();i++) {
			arr[N.charAt(i) - 'a']++; // 위 값은 0을 제외하고 ab가 있다면
			// 0번째 배열과 1번째 배열이 1의 값을 가진다.
			// 위상정렬 푸는 것처럼 (degree라 생각)
		}
		ans = 0;
		// 문자열 저장 완료
		solve(0,0);
		System.out.println(ans);
	}
	// 개수와 시작점인 idx
	public static void solve(int cnt,int idx) {
		if(cnt==N.length()) {
			// cnt개수만큼 모두 결과가 제대로 만들어졌으면
			// ans를 +1해주고 return해준다.
			ans++;
			return;
		}
		// 알파벳 순으로 재귀를 돌려보자 
		for(int i=0;i<26;i++) {
			// 먼저 알파벳이 있어야 하고 , 전에 알파벳이 지금 들어갈 알파벳과 달라야함
			
			// 1. 먼저 현재 arr배열의 값이 0이 아니어야함
			// 2. 다음에 올 값이 현재의 값과 달라야함 
			// (중요한 것은 첫번쨰에 a가 올 경우에는 제외- a가 무조건 있는 조건에서)
			
			// 이렇게 될경우 맨처음이 0으로 시작해서 첫번째 알파벳이
			// a가 와야할경우가 불가능하기 때문에
			// cnt==0일 때는 예외로 가능하게 처리
			if(arr[i]!=0 && (idx!=i || cnt ==0)) {
				arr[i] --;
				solve(cnt+1,i); // 개수는 +1시켜주고 현재 알파벳 반환
				// 재귀로 현재 알파벳을 포함하지 않는 경우에는 다시 +해줌 
				arr[i]++; // 포함안할 경우 +1;
			}
		}

	}
}
